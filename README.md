# 26 种设计模式
详细笔记见[此处](https://github.com/DuanJiaNing/Learning-materials/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)

## 装饰模式(decorator)
装饰模式和适配器模式都属于包装模式(wrapper)，装饰模式的主要作用是：对客户端透明的给一个对象附加上更多的责任，
装饰模式的典型应用是java i/o流。
装饰模式由4种角色构成：
1. Component：抽象构件
2. ConcreteComponent: 具体构件
3. Decorator：抽象装饰构件
4. ConcreteDecorator：具体装饰构件

## 享元模式(flyweight)
享元模式以共享的方式高效的支持大量细粒度对象的重用，复用内存中已存在的对象，降低系统创建对象的性能消耗。
享元对象能做到共享的关键是区分了内部状态和外部状态。 
1. 内部状态：可以共享，不会随环境改变而改变。
2. 外部状态：不可以共享，会随环境改变而改变。
享元模式由4种角色构成：
1. FlyWeight：抽象享元类
2. UnsharedConcreteFlyWeight：非共享享元类
3. ConcreteFlyWeight：具体享元类
4. FlyWeightFactory：享元工厂类

## 观察者模式(observer)
观察者模式面向的需求是：A 对象（观察者）对 B 对象（被观察者）的某种变化高度敏感，需要在 B 变化的一瞬间做出反应。
1. Observable：即被观察者，也可以被叫做主题（Subject）是被观察的对象。通常有注册方法（register），取消注册方法(remove)和通知方法(notify)。
2. Observer：即观察者，可以接收到主题的更新。当对某个主题感兴趣的时候需要注册自己，在不需要接收更新时进行注销操作。

## 代理模式(proxy)
提供了对目标对象一种新的访问方式，即通过代理对象访问目标对象。这样做的好处是：可以在目标对象已有实现的基础上，增加额外的功能，即扩展目标对象的功能。
代理模式可细分为三种：
1. 静态代理
2. 动态代理（JDK代理）
3. Cglib代理

## 单例模式(singleton)
单例模式必须保证类只有一个实例存在，使用者无法自由构建对象，避免产生过多对象消耗资源。
单例模式有5种写法：
1. 饿汉单例
2. 懒汉单例
3. 静态内部类
4. DCL单例
5. 枚举单例

## 工厂模式(factory)
通过工厂模式可以轻松方便的构造对象实例，而不必关心构造对象实例的细节和复杂过程。
工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 
工厂模式可分为三种：
1. 简单工厂模式
2. 工厂方法模式
3. 抽象工厂模式

## 原型模式（Prototype）
该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象，使用原型实例指定创建对象的种类，
并且通过拷贝这些原型创建新的对象。简单的说就是对象的拷贝生成新的对象（对象的克隆），原型模式是一种对象创建型模式。
原型模式涉及到了java深拷贝和浅拷贝的问题。

## 代理模式（proxy）
代理模式提供了对目标对象不同于常规（new或静态工厂）的一种访问方式，即通过代理对象访问目标对象。这样做的好处是：
可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。
代理模式有三种模式：
1. 静态代理
2. 动态代理（接口代理，JDK代理）
3. Cglib代理